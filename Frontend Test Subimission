import React, { useEffect, useMemo, useState } from "react";
import { createRoot } from "react-dom/client";
import { QueryClient, QueryClientProvider, useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { motion, AnimatePresence } from "framer-motion";
import { BarChart, Bar, ResponsiveContainer, XAxis, YAxis, Tooltip, CartesianGrid } from "recharts";
import {
  ChartNoAxesColumn,
  Loader2,
  Plus,
  Save,
  Trash2,
  Upload,
  Moon,
  SunMedium,
  WifiOff,
  Wifi,
  RefreshCw,
  ChevronRight,
  LogOut
} from "lucide-react";
import {
  Button,
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Toaster } from "@/components/ui/toaster";
import { useToast } from "@/components/ui/use-toast";


const delay = (ms: number) => new Promise((res) => setTimeout(res, ms));

const STORAGE_KEY = "prodready-demo-items";

type Item = {
  id: string;
  name: string;
  price: number;
  stock: number;
  category: string;
  notes?: string;
  createdAt: string; // ISO
};

type CreateItem = Omit<Item, "id" | "createdAt">;

type ApiState = {
  failRate: number; // 0..1 artificial failure rate
  minLatency: number; // ms
  maxLatency: number; // ms
};

const apiState: ApiState = {
  failRate: 0.15,
  minLatency: 300,
  maxLatency: 900,
};

function randomLatency() {
  const { minLatency, maxLatency } = apiState;
  return Math.floor(Math.random() * (maxLatency - minLatency + 1)) + minLatency;
}

function maybeFail() {
  if (Math.random() < apiState.failRate) {
    const errors = [
      { code: 503, message: "Service Unavailable. Try again." },
      { code: 408, message: "Request Timeout. Please retry." },
      { code: 429, message: "Too Many Requests. Slow down." },
    ];
    const err = errors[Math.floor(Math.random() * errors.length)];
    const e = new Error(err.message) as Error & { status?: number };
    e.status = err.code;
    throw e;
  }
}

function loadAll(): Item[] {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw);
  } catch {
    return [];
  }
}

function saveAll(items: Item[]) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
}

const api = {
  async list(): Promise<Item[]> {
    await delay(randomLatency());
    maybeFail();
    return loadAll();
  },
  async create(input: CreateItem): Promise<Item> {
    await delay(randomLatency());
    maybeFail();
    const items = loadAll();
    const item: Item = {
      id: crypto.randomUUID(),
      createdAt: new Date().toISOString(),
      ...input,
    };
    items.unshift(item);
    saveAll(items);
    return item;
  },
  async remove(id: string): Promise<{ id: string }> {
    await delay(randomLatency());
    maybeFail();
    const items = loadAll().filter((i) => i.id !== id);
    saveAll(items);
    return { id };
  },
  async seed(): Promise<number> {
    await delay(200);
    const existing = loadAll();
    if (existing.length > 0) return existing.length;
    const cats = ["Electronics", "Apparel", "Home", "Sports"];
    const seedItems: Item[] = Array.from({ length: 14 }).map((_, idx) => ({
      id: crypto.randomUUID(),
      name: `Sample Item ${idx + 1}`,
      price: Math.round(1000 + Math.random() * 9000) / 100,
      stock: Math.floor(Math.random() * 200),
      category: cats[Math.floor(Math.random() * cats.length)],
      notes: Math.random() > 0.7 ? "Top seller" : undefined,
      createdAt: new Date(Date.now() - Math.random() * 1000 * 60 * 60 * 24 * 20).toISOString(),
    }));
    saveAll(seedItems);
    return seedItems.length;
  },
};


const itemSchema = z.object({
  name: z.string().min(2, "Name is too short"),
  price: z.number().min(0, "Price must be positive"),
  stock: z.number().int().min(0, "Stock cannot be negative"),
  category: z.string().min(2, "Choose a category"),
  notes: z.string().max(200).optional(),
});

type ItemForm = z.infer<typeof itemSchema>;


function formatCurrency(n: number) {
  try {
    return new Intl.NumberFormat(undefined, { style: "currency", currency: "USD" }).format(n);
  } catch {
    return `$${n.toFixed(2)}`;
  }
}

function timeAgo(iso: string) {
  const diff = Date.now() - new Date(iso).getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return "just now";
  if (mins < 60) return `${mins}m ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs}h ago`;
  const days = Math.floor(hrs / 24);
  return `${days}d ago`;
}


class ErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean; message?: string }> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(err: Error) {
    return { hasError: true, message: err.message ?? "Unknown error" };
  }
  componentDidCatch(error: Error, info: any) {
    console.error("UI ErrorBoundary caught: ", error, info);
  }
  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen grid place-items-center p-6">
          <Card className="max-w-lg w-full">
            <CardHeader>
              <CardTitle>Something went wrong</CardTitle>
              <CardDescription>{this.state.message}</CardDescription>
            </CardHeader>
            <CardContent>
              <Button onClick={() => this.setState({ hasError: false, message: undefined })}>
                Try to recover
              </Button>
            </CardContent>
          </Card>
        </div>
      );
    }
    return this.props.children as any;
  }
}


function useSystemPrefersDark() {
  const [pref, setPref] = useState(false);
  useEffect(() => {
    const mq = window.matchMedia("(prefers-color-scheme: dark)");
    setPref(mq.matches);
    const handler = (e: MediaQueryListEvent) => setPref(e.matches);
    mq.addEventListener("change", handler);
    return () => mq.removeEventListener("change", handler);
  }, []);
  return pref;
}

function ThemeToggle() {
  const [dark, setDark] = useState<boolean>(() => {
    const v = localStorage.getItem("_demo_dark");
    return v ? v === "1" : false;
  });
  const system = useSystemPrefersDark();
  useEffect(() => {
    const effective = dark ?? system;
    document.documentElement.classList.toggle("dark", effective);
  }, [dark, system]);
  useEffect(() => {
    localStorage.setItem("_demo_dark", dark ? "1" : "0");
  }, [dark]);
  return (
    <Button variant="outline" size="icon" onClick={() => setDark((d) => !d)} aria-label="Toggle theme">
      {document.documentElement.classList.contains("dark") ? <SunMedium className="h-4 w-4"/> : <Moon className="h-4 w-4"/>}
    </Button>
  );
}


function TopBar({ onRefresh }: { onRefresh: () => void }) {
  const [online, setOnline] = useState<boolean>(navigator.onLine);
  useEffect(() => {
    const on = () => setOnline(true);
    const off = () => setOnline(false);
    window.addEventListener("online", on);
    window.addEventListener("offline", off);
    return () => {
      window.removeEventListener("online", on);
      window.removeEventListener("offline", off);
    };
  }, []);
  return (
    <div className="w-full sticky top-0 z-40 backdrop-blur supports-[backdrop-filter]:bg-background/60 bg-background/80 border-b">
      <div className="mx-auto max-w-7xl px-4 py-3 flex items-center gap-3">
        <ChartNoAxesColumn className="h-5 w-5"/>
        <span className="font-semibold">ProdReady Demo</span>
        <Badge className="ml-1">React + RQ + RHF + Zod</Badge>
        <div className="ml-auto flex items-center gap-2">
          <Badge variant={online ? "secondary" : "destructive"} className="gap-1">
            {online ? <Wifi className="h-3 w-3"/> : <WifiOff className="h-3 w-3"/>}
            {online ? "Online" : "Offline"}
          </Badge>
          <Button variant="outline" size="icon" onClick={onRefresh} aria-label="Refresh data">
            <RefreshCw className="h-4 w-4"/>
          </Button>
          <ThemeToggle />
        </div>
      </div>
    </div>
  );
}


function useItems() {
  return useQuery({
    queryKey: ["items"],
    queryFn: () => api.list(),
    retry: 3,
    staleTime: 5000,
  });
}

function CreateItemForm() {
  const { toast } = useToast();
  const qc = useQueryClient();
  const form = useForm<ItemForm>({
    resolver: zodResolver(itemSchema),
    defaultValues: { name: "", price: 0, stock: 0, category: "", notes: "" },
    mode: "onTouched",
  });

  const mutation = useMutation({
    mutationFn: async (data: ItemForm) => {
      return api.create(data);
    },
    onMutate: async (data) => {
      // Optimistic update
      await qc.cancelQueries({ queryKey: ["items"] });
      const prev = qc.getQueryData<Item[]>(["items"]) ?? [];
      const optimistic: Item = {
        id: `optimistic-${Date.now()}`,
        createdAt: new Date().toISOString(),
        ...data,
      };
      qc.setQueryData<Item[]>(["items"], [optimistic, ...prev]);
      return { prev };
    },
    onError: (err, _variables, ctx) => {
      qc.setQueryData(["items"], ctx?.prev ?? []);
      toast({ title: "Create failed", description: (err as Error).message });
    },
    onSuccess: () => {
      toast({ title: "Item added", description: "Saved successfully" });
    },
    onSettled: () => {
      qc.invalidateQueries({ queryKey: ["items"] });
    },
  });

  function onSubmit(values: ItemForm) {
    mutation.mutate(values);
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Add Item</CardTitle>
        <CardDescription>Create new inventory records with validation</CardDescription>
      </CardHeader>
      <CardContent>
        <form className="grid md:grid-cols-2 gap-4" onSubmit={form.handleSubmit(onSubmit)} noValidate>
          <div>
            <Label>Name</Label>
            <Input aria-invalid={!!form.formState.errors.name} placeholder="e.g., Wireless Mouse" {...form.register("name")}/>
            {form.formState.errors.name && (
              <p className="text-sm text-destructive mt-1">{form.formState.errors.name.message}</p>
            )}
          </div>
          <div>
            <Label>Price (USD)</Label>
            <Input type="number" step="0.01" inputMode="decimal" {...form.register("price", { valueAsNumber: true })} />
            {form.formState.errors.price && (
              <p className="text-sm text-destructive mt-1">{form.formState.errors.price.message}</p>
            )}
          </div>
          <div>
            <Label>Stock</Label>
            <Input type="number" inputMode="numeric" {...form.register("stock", { valueAsNumber: true })} />
            {form.formState.errors.stock && (
              <p className="text-sm text-destructive mt-1">{form.formState.errors.stock.message}</p>
            )}
          </div>
          <div>
            <Label>Category</Label>
            <Input placeholder="e.g., Electronics" {...form.register("category")} />
            {form.formState.errors.category && (
              <p className="text-sm text-destructive mt-1">{form.formState.errors.category.message}</p>
            )}
          </div>
          <div className="md:col-span-2">
            <Label>Notes</Label>
            <Textarea rows={3} placeholder="Optional information" {...form.register("notes")} />
            {form.formState.errors.notes && (
              <p className="text-sm text-destructive mt-1">{form.formState.errors.notes.message}</p>
            )}
          </div>
          <div className="md:col-span-2 flex gap-2">
            <Button type="submit" disabled={mutation.isPending}>
              {mutation.isPending ? <Loader2 className="h-4 w-4 mr-2 animate-spin"/> : <Save className="h-4 w-4 mr-2"/>}
              Save
            </Button>
            <Button type="button" variant="secondary" onClick={() => form.reset()}>
              Reset
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}

function ItemsTable() {
  const { data, isLoading, isError, error, refetch, isFetching } = useItems();
  const qc = useQueryClient();
  const { toast } = useToast();
  const [search, setSearch] = useState("");
  const [sortBy, setSortBy] = useState<keyof Item | "none">("none");

  const mutation = useMutation({
    mutationFn: async (id: string) => api.remove(id),
    onMutate: async (id) => {
      await qc.cancelQueries({ queryKey: ["items"] });
      const prev = qc.getQueryData<Item[]>(["items"]) ?? [];
      qc.setQueryData<Item[]>(["items"], prev.filter((i) => i.id !== id));
      return { prev };
    },
    onError: (err, _id, ctx) => {
      qc.setQueryData(["items"], ctx?.prev ?? []);
      toast({ title: "Delete failed", description: (err as Error).message });
    },
    onSuccess: () => toast({ title: "Deleted", description: "Item removed" }),
    onSettled: () => qc.invalidateQueries({ queryKey: ["items"] }),
  });

  const filtered = useMemo(() => {
    const list = data ?? [];
    const q = search.trim().toLowerCase();
    const l = q ? list.filter((i) => [i.name, i.category, i.notes ?? ""].some((f) => f.toLowerCase().includes(q))) : list;
    if (sortBy === "none") return l;
    const sorted = [...l].sort((a, b) => {
      const va = a[sortBy] as any;
      const vb = b[sortBy] as any;
      if (typeof va === "number" && typeof vb === "number") return vb - va;
      return String(vb).localeCompare(String(va));
    });
    return sorted;
  }, [data, search, sortBy]);

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Inventory</CardTitle>
          <CardDescription>Loading data…</CardDescription>
        </CardHeader>
        <CardContent className="py-10 flex items-center justify-center">
          <Loader2 className="h-6 w-6 animate-spin"/>
        </CardContent>
      </Card>
    );
  }

  if (isError) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Inventory</CardTitle>
          <CardDescription>Could not load data</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertTitle>Fetch error</AlertTitle>
            <AlertDescription>{(error as Error).message}</AlertDescription>
          </Alert>
          <div className="mt-4 flex gap-2">
            <Button onClick={() => refetch()}>
              Retry
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="gap-2">
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Inventory</CardTitle>
            <CardDescription>{filtered.length} items {isFetching && <span className="ml-2 inline-flex items-center text-xs"><Loader2 className="h-3 w-3 mr-1 animate-spin"/>Refreshing…</span>}</CardDescription>
          </div>
          <div className="flex items-center gap-2">
            <Input placeholder="Search…" value={search} onChange={(e) => setSearch(e.target.value)} className="w-40 md:w-64"/>
            <select
              aria-label="Sort by"
              className="h-9 rounded-md border bg-background px-2"
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as any)}
            >
              <option value="none">Sort: None</option>
              <option value="price">Sort: Price ↓</option>
              <option value="stock">Sort: Stock ↓</option>
              <option value="createdAt">Sort: Newest</option>
              <option value="name">Sort: Name Z→A</option>
              <option value="category">Sort: Category Z→A</option>
            </select>
          </div>
        </div>
      </CardHeader>
      <CardContent className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead className="text-left">
            <tr className="border-b">
              <th className="py-2 pr-4">Name</th>
              <th className="py-2 pr-4">Category</th>
              <th className="py-2 pr-4">Price</th>
              <th className="py-2 pr-4">Stock</th>
              <th className="py-2 pr-4">Added</th>
              <th className="py-2 pr-4 text-right">Actions</th>
            </tr>
          </thead>
          <tbody>
            <AnimatePresence initial={false}>
              {filtered.map((it) => (
                <motion.tr
                  key={it.id}
                  initial={{ opacity: 0, y: -4 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: 4 }}
                  transition={{ duration: 0.18 }}
                  className="border-b last:border-0"
                >
                  <td className="py-3 pr-4 font-medium">{it.name}</td>
                  <td className="py-3 pr-4"><Badge variant="secondary">{it.category}</Badge></td>
                  <td className="py-3 pr-4">{formatCurrency(it.price)}</td>
                  <td className="py-3 pr-4">{it.stock}</td>
                  <td className="py-3 pr-4">{timeAgo(it.createdAt)}</td>
                  <td className="py-3 pr-2">
                    <div className="flex items-center justify-end gap-2">
                      <Button variant="ghost" size="icon" aria-label={`Delete ${it.name}`} onClick={() => mutation.mutate(it.id)}>
                        <Trash2 className="h-4 w-4"/>
                      </Button>
                    </div>
                  </td>
                </motion.tr>
              ))}
            </AnimatePresence>
          </tbody>
        </table>
      </CardContent>
    </Card>
  );
}


function InventoryChart() {
  const { data = [] } = useItems();
  const chart = useMemo(() => {
    const groups: Record<string, { category: string; stock: number }> = {};
    for (const it of data) {
      groups[it.category] = groups[it.category] || { category: it.category, stock: 0 };
      groups[it.category].stock += it.stock;
    }
    return Object.values(groups);
  }, [data]);
  return (
    <Card>
      <CardHeader>
        <CardTitle>Stock by Category</CardTitle>
        <CardDescription>Aggregated inventory distribution</CardDescription>
      </CardHeader>
      <CardContent className="h-72">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart data={chart}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="category" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="stock" />
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
}


function ReliabilityPanel() {
  const [failRate, setFailRate] = useState(apiState.failRate);
  const [minLat, setMinLat] = useState(apiState.minLatency);
  const [maxLat, setMaxLat] = useState(apiState.maxLatency);
  const qc = useQueryClient();

  function apply() {
    apiState.failRate = Math.min(0.9, Math.max(0, failRate));
    apiState.minLatency = Math.max(0, Math.min(minLat, maxLat));
    apiState.maxLatency = Math.max(apiState.minLatency, maxLat);
    qc.invalidateQueries({ queryKey: ["items"] });
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Reliability Controls</CardTitle>
        <CardDescription>Simulate production error conditions</CardDescription>
      </CardHeader>
      <CardContent className="grid md:grid-cols-3 gap-4">
        <div>
          <Label>Failure Rate</Label>
          <div className="flex items-center gap-2">
            <Input type="number" step="0.01" value={failRate} onChange={(e) => setFailRate(parseFloat(e.target.value || "0"))} />
            <span className="text-xs text-muted-foreground">0..0.9</span>
          </div>
        </div>
        <div>
          <Label>Min Latency (ms)</Label>
          <Input type="number" value={minLat} onChange={(e) => setMinLat(parseInt(e.target.value || "0"))} />
        </div>
        <div>
          <Label>Max Latency (ms)</Label>
          <Input type="number" value={maxLat} onChange={(e) => setMaxLat(parseInt(e.target.value || "0"))} />
        </div>
        <div className="md:col-span-3 flex gap-2">
          <Button onClick={apply}><Upload className="h-4 w-4 mr-2"/>Apply</Button>
          <span className="text-sm text-muted-foreground">Current: fail {(apiState.failRate*100).toFixed(0)}% · {apiState.minLatency}-{apiState.maxLatency}ms</span>
        </div>
      </CardContent>
    </Card>
  );
}


const routes = ["dashboard", "inventory", "settings"] as const;

type Route = typeof routes[number];

function Sidebar({ route, setRoute }: { route: Route; setRoute: (r: Route) => void }) {
  const items: { key: Route; label: string; icon?: React.ReactNode }[] = [
    { key: "dashboard", label: "Dashboard", icon: <ChevronRight className="h-4 w-4"/> },
    { key: "inventory", label: "Inventory", icon: <ChevronRight className="h-4 w-4"/> },
    { key: "settings", label: "Settings", icon: <ChevronRight className="h-4 w-4"/> },
  ];
  return (
    <aside className="w-full md:w-60 shrink-0">
      <Card className="sticky top-20">
        <CardHeader>
          <CardTitle>Navigation</CardTitle>
          <CardDescription>Select a section</CardDescription>
        </CardHeader>
        <CardContent className="grid gap-2">
          {items.map((i) => (
            <Button key={i.key} variant={route === i.key ? "default" : "outline"} className="justify-start" onClick={() => setRoute(i.key)}>
              {i.icon}
              <span className="ml-2">{i.label}</span>
            </Button>
          ))}
        </CardContent>
      </Card>
    </aside>
  );
}

function Dashboard() {
  const { data = [], isFetching } = useItems();
  const totalValue = useMemo(() => data.reduce((sum, it) => sum + it.price * it.stock, 0), [data]);
  const lowStock = useMemo(() => data.filter((i) => i.stock < 10).length, [data]);
  return (
    <div className="grid gap-4">
      <div className="grid md:grid-cols-3 gap-4">
        <Card>
          <CardHeader>
            <CardTitle>Total Items</CardTitle>
            <CardDescription>All records</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-bold">{data.length}{isFetching && <Loader2 className="h-4 w-4 ml-2 inline animate-spin"/>}</CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Inventory Value</CardTitle>
            <CardDescription>Est. retail</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-bold">{formatCurrency(totalValue)}</CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Low Stock</CardTitle>
            <CardDescription>{"< 10 units"}</CardDescription>
          </CardHeader>
          <CardContent className="text-3xl font-bold">{lowStock}</CardContent>
        </Card>
      </div>
      <InventoryChart />
    </div>
  );
}

function Settings() {
  return (
    <div className="grid gap-4">
      <ReliabilityPanel />
      <Card>
        <CardHeader>
          <CardTitle>Account</CardTitle>
          <CardDescription>Demo-only controls</CardDescription>
        </CardHeader>
        <CardContent className="flex items-center gap-3">
          <Button variant="outline"><LogOut className="h-4 w-4 mr-2"/>Sign out</Button>
          <span className="text-sm text-muted-foreground">(No-op in demo)</span>
        </CardContent>
      </Card>
    </div>
  );
}


function AppShell() {
  const qc = useQueryClient();
  const { toast } = useToast();
  const [route, setRoute] = useState<Route>("dashboard");

  useEffect(() => {
    api.seed().then(() => qc.invalidateQueries({ queryKey: ["items"] }));
  }, []);

  function refresh() {
    qc.invalidateQueries({ queryKey: ["items"] });
    toast({ title: "Refreshing", description: "Fetching latest data" });
  }

  return (
    <div className="min-h-screen bg-background text-foreground">
      <TopBar onRefresh={refresh} />
      <main className="mx-auto max-w-7xl px-4 py-6 grid md:grid-cols-[240px_1fr] gap-4">
        <Sidebar route={route} setRoute={setRoute} />
        <div className="grid gap-4">
          {route === "dashboard" && <Dashboard />}
          {route === "inventory" && (
            <div className="grid gap-4">
              <CreateItemForm />
              <ItemsTable />
            </div>
          )}
          {route === "settings" && <Settings />}
        </div>
      </main>
      <Toaster />
    </div>
  );
}


const client = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retryDelay: (attempt) => Math.min(1000 * attempt, 3000),
    },
  },
});

export default function ProductionReadyDemoApp() {
  return (
    <QueryClientProvider client={client}>
      <ErrorBoundary>
        <AppShell />
      </ErrorBoundary>
    </QueryClientProvider>
  );
}

// For standalone mounting when this file is used directly (optional)
if (typeof document !== "undefined") {
  const el = document.getElementById("root");
  if (el && !el.dataset.mounted) {
    const root = createRoot(el);
    root.render(<ProductionReadyDemoApp/>);
    el.dataset.mounted = "1";
  }
}

